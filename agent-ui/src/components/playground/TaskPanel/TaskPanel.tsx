'use client'

import { useEffect, useRef, useState } from 'react'
import { usePlaygroundStore } from '@/store'
import { getFathomTasksAPI } from '@/api/playground'
import { DateFilter } from './DateFilter'
import { BatchFilter } from './BatchFilter'
import { TaskList } from './TaskList'
import { SearchFilter } from './SearchFilter'
import { Separator } from '@/components/ui/separator'
import { toast } from 'sonner'
import { cn } from '@/lib/utils'

interface TaskPanelProps {
  showHeader?: boolean
  className?: string
  /**
   * When provided, overrides internal visibility check.
   * Useful for forcing visibility inside overlays/trays even after chat starts.
   */
  visibleOverride?: boolean
}

export function TaskPanel({ showHeader = true, className, visibleOverride }: TaskPanelProps) {
  const { 
    taskGroups, 
    setTaskGroups, 
    taskFilter,
    isTaskPanelVisible,
    selectedEndpoint 
  } = usePlaygroundStore()

  const [isLoading, setIsLoading] = useState(false)
  const abortRef = useRef<AbortController | null>(null)

  // Load tasks from LUSID API
  useEffect(() => {
    const loadTasks = async () => {
      if (!selectedEndpoint) return
      
      setIsLoading(true)
      try {
        // cancel in-flight
        abortRef.current?.abort()
        const controller = new AbortController()
        abortRef.current = controller
        // Use backend endpoint (port 8000) instead of playground endpoint
        const backendUrl = selectedEndpoint.replace(':7777', ':8000')
        const groups = await getFathomTasksAPI(backendUrl, taskFilter, controller.signal)
        setTaskGroups(groups)
      } catch (error) {
        // Ignore aborted requests generated by debounced typing/backspacing
        if ((error as any)?.name === 'AbortError') return
        console.error('Failed to load tasks:', error)
        // Error toast is managed in API layer for non-abort cases
        setTaskGroups([]) // Clear tasks on error
      } finally {
        setIsLoading(false)
      }
    }

    // Set loading immediately to avoid flashing empty state before the debounced fetch starts
    setIsLoading(true)
    // debounce 300ms for rapid filter changes
    const id = setTimeout(loadTasks, 300)
    return () => {
      clearTimeout(id)
      abortRef.current?.abort()
    }
  }, [selectedEndpoint, taskFilter, setTaskGroups])

  const isVisible = visibleOverride ?? isTaskPanelVisible
  if (!isVisible) {
    return null
  }

  // Filter task groups based on current filters
  const filteredGroups = taskGroups.filter(group => {
    // Date filter
    if (taskFilter.dateFrom || taskFilter.dateTo) {
      const createdDate = new Date(group.ultimateParent.version.asAtCreated)
      const createdDateOnly = new Date(createdDate.getFullYear(), createdDate.getMonth(), createdDate.getDate())
      
      if (taskFilter.dateFrom) {
        const filterFromDate = new Date(taskFilter.dateFrom)
        const filterFromDateOnly = new Date(filterFromDate.getFullYear(), filterFromDate.getMonth(), filterFromDate.getDate())
        if (createdDateOnly < filterFromDateOnly) {
          return false
        }
      }
      if (taskFilter.dateTo) {
        const filterToDate = new Date(taskFilter.dateTo)
        const filterToDateOnly = new Date(filterToDate.getFullYear(), filterToDate.getMonth(), filterToDate.getDate())
        if (createdDateOnly > filterToDateOnly) {
          return false
        }
      }
    }

    // Search filter
    if (taskFilter.searchQuery) {
      const query = taskFilter.searchQuery.toLowerCase()
      const parentMatches = group.ultimateParent.taskDefinitionDisplayName.toLowerCase().includes(query) ||
                           group.ultimateParent.state.toLowerCase().includes(query)
      const childMatches = group.children.some(child => 
        child.taskDefinitionDisplayName.toLowerCase().includes(query) ||
        child.state.toLowerCase().includes(query)
      )
      if (!parentMatches && !childMatches) {
        return false
      }
    }

    // Batch filter (correlation IDs)
    if (taskFilter.correlationIds && taskFilter.correlationIds.length > 0) {
      const parentCorrelationIds = group.ultimateParent.correlationIds || []
      const childCorrelationIds = group.children.flatMap(child => child.correlationIds || [])
      const allCorrelationIds = [...parentCorrelationIds, ...childCorrelationIds]
      
      const hasMatchingCorrelation = taskFilter.correlationIds.some(filterId => 
        allCorrelationIds.includes(filterId)
      )
      
      if (!hasMatchingCorrelation) {
        return false
      }
    }

    // State filter
    if (taskFilter.states && taskFilter.states.length > 0) {
      const parentStateMatches = taskFilter.states.includes(group.ultimateParent.state as any)
      const childStateMatches = group.children.some(child => 
        taskFilter.states!.includes(child.state as any)
      )
      if (!parentStateMatches && !childStateMatches) {
        return false
      }
    }

    return true
  })

  return (
    <div
      className={cn(
        'flex h-full flex-col rounded-xl border',
        showHeader ? 'bg-card' : 'bg-background-secondary',
        className
      )}
    >
      {/* Header (optional) */}
      {showHeader && (
        <div className="flex flex-col gap-4 p-6">
          <div className="text-center">
            <h2 className="text-2xl font-semibold text-foreground">
              Aggregation Error Tasks
            </h2>
            <p className="text-sm text-muted-foreground mt-2">
              Select tasks to investigate data quality issues
            </p>
          </div>
          <Separator className="bg-border/30" />
          {/* Filters */}
          <div className="flex justify-between items-center gap-4">
            <div className="flex items-center gap-3">
              <div className="w-40">
                <DateFilter />
              </div>
              <div className="w-44">
                <BatchFilter />
              </div>
            </div>
            <div className="w-64">
              <SearchFilter />
            </div>
          </div>
        </div>
      )}

      {!showHeader && (
        <div className="flex flex-col gap-4 p-4 border-b border-border/30">
          <div className="flex justify-between items-center gap-4">
            <div className="flex items-center gap-3">
              <div className="w-40">
                <DateFilter />
              </div>
              <div className="w-44">
                <BatchFilter />
              </div>
            </div>
            <div className="w-64">
              <SearchFilter />
            </div>
          </div>
        </div>
      )}

      {/* Task List */}
      <div className="flex-1 overflow-hidden">
        <TaskList groups={filteredGroups} isLoading={isLoading} />
      </div>

      {/* Footer */}
      <div className="p-4 border-t border-border/30">
        <p className="text-xs text-muted-foreground text-center">
          {filteredGroups.length} task group{filteredGroups.length !== 1 ? 's' : ''} â€¢ 
          {filteredGroups.reduce((sum, group) => sum + group.totalCount, 0)} total tasks
        </p>
      </div>
    </div>
  )
}
